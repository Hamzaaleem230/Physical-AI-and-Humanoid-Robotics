# C:\Users\syeda\...\backend\auth-server\app\main.py

import os
import uuid
from dotenv import load_dotenv
from fastapi import FastAPI, Depends, HTTPException, status, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from pydantic import BaseModel, EmailStr
from typing import Optional

# Local imports (relative)
from .database import get_db, create_db_tables
from .models import User, Profile

# Load environment variables
load_dotenv()

app = FastAPI()

# CORS configuration
CORS_ORIGIN = os.getenv("CORS_ORIGIN", "http://localhost:3000")
origins = [CORS_ORIGIN]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic request/response models
class UserCreate(BaseModel):
    email: EmailStr
    password: str
    full_name: str
    skill_level: Optional[str] = None
    hardware: Optional[str] = None
    robotics_experience: Optional[str] = None
    os: Optional[str] = None
    learning_mode: Optional[str] = None

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserProfileResponse(BaseModel):
    email: EmailStr
    full_name: str
    skill_level: Optional[str] = None
    hardware: Optional[str] = None
    robotics_experience: Optional[str] = None
    os: Optional[str] = None
    learning_mode: Optional[str] = None

    class Config:
        from_attributes = True

class ProfileUpdate(BaseModel):
    full_name: Optional[str] = None
    skill_level: Optional[str] = None
    hardware: Optional[str] = None
    robotics_experience: Optional[str] = None
    os: Optional[str] = None
    learning_mode: Optional[str] = None

# Startup: ensure tables exist
@app.on_event("startup")
def on_startup():
    create_db_tables()

@app.get("/")
def read_root():
    return {"message": "Auth Service is running!"}

@app.post("/auth/signup")
async def signup(user_data: UserCreate, db: Session = Depends(get_db)):
    # prevent duplicate emails
    db_user = db.query(User).filter(User.email == user_data.email).first()
    if db_user:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Email already registered")

    # NOTE: Password hashing should be used in production (this keeps your current dev behavior)
    hashed_password = user_data.password

    # Create user (id is generated by model default)
    new_user = User(email=user_data.email, password_hash=hashed_password)
    db.add(new_user)
    db.commit()
    db.refresh(new_user)

    # Create profile
    new_profile = Profile(
        user_id=new_user.id,
        full_name=user_data.full_name,
        skill_level=user_data.skill_level,
        hardware=user_data.hardware,
        robotics_experience=user_data.robotics_experience,
        os=user_data.os,
        learning_mode=user_data.learning_mode,
    )
    db.add(new_profile)
    db.commit()
    db.refresh(new_profile)

    return {"message": "User and profile created successfully", "user_id": new_user.id}

@app.post("/auth/signin")
async def signin(user_credentials: UserLogin, response: Response, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.email == user_credentials.email).first()
    if not db_user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password")

    # TODO: Replace with proper password hash check in production
    if db_user.password_hash != user_credentials.password:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password")

    # Set a simple HTTP-only cookie with the user's ID (dev-friendly)
    # Cookie name: session_user_id
    # Value: string UUID
    response.set_cookie(
        key="session_user_id",
        value=str(db_user.id),
        httponly=True,
        samesite="lax",
        max_age=60 * 60 * 24 * 7  # 7 days
    )

    return {"message": "User signed in successfully", "user_id": db_user.id}

@app.get("/auth/me", response_model=UserProfileResponse)
async def get_current_user_profile(request: Request, db: Session = Depends(get_db)):
    # Read session cookie
    session_user_id = request.cookies.get("session_user_id")
    if not session_user_id:
        # frontend treats 401/404 as unauthenticated (api.ts returns null)
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")

    # Lookup user by id (IDs are stored as strings)
    current_user = db.query(User).filter(User.id == session_user_id).join(Profile).first()
    if not current_user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")

    if not current_user.profile:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User profile not found")

    return {
        "email": current_user.email,
        "full_name": current_user.profile.full_name,
        "skill_level": current_user.profile.skill_level,
        "hardware": current_user.profile.hardware,
        "robotics_experience": current_user.profile.robotics_experience,
        "os": current_user.profile.os,
        "learning_mode": current_user.profile.learning_mode,
    }

@app.post("/auth/signout")
async def signout(response: Response):
    # Delete cookie on signout
    response.delete_cookie("session_user_id")
    return {"message": "User signed out successfully"}

@app.post("/auth/profile-update")
async def update_user_profile(profile_data: ProfileUpdate, request: Request, db: Session = Depends(get_db)):
    session_user_id = request.cookies.get("session_user_id")
    if not session_user_id:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")

    current_user = db.query(User).filter(User.id == session_user_id).join(Profile).first()
    if not current_user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No user found")

    # update only provided fields
    update_data = profile_data.dict(exclude_unset=True)
    for field, value in update_data.items():
        # apply to profile model
        if hasattr(current_user.profile, field):
            setattr(current_user.profile, field, value)

    db.commit()
    db.refresh(current_user.profile)

    return {"message": "Profile updated successfully", "user_id": current_user.id}
